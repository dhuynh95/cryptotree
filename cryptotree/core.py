# AUTOGENERATED! DO NOT EDIT! File to edit: nbs\00_core.ipynb (unless otherwise specified).

__all__ = ['shift_bit_eps', 'create_base_vectors', 'create_linear_system', 'BitComparison', 'create_test_cases_x',
           'create_test_cases_y', 'create_parent_of', 'create_leaf_to_path', 'path_to_weight']

# Cell
import numpy as np
from typing import List
import torch.nn as nn
import torch

def shift_bit_eps(bit: int, eps: float = 0.5):
    assert bit in [0,1], "Bit must be 0 or 1"
    return (2 * eps - 1) * bit + 1 - eps

def create_base_vectors(circuit: List[int], eps: float = 0.5):
    vectors = []
    n = len(circuit)

    for i in range(n):
        vector = list(circuit).copy()
        vector[i] = shift_bit_eps(vector[i], eps=eps)
        vectors.append(vector)

    return vectors

def create_linear_system(vectors: List[List[float]]):
    X = np.array(vectors)

    y = -X[:,-1]

    X[:,-1] = 1

    return X,y

class BitComparison(nn.Module):
    def __init__(self,target: List[int], eps : float = 0.5):
        super(BitComparison, self).__init__()

        vectors = create_base_vectors(target, eps=eps)
        X,y = create_linear_system(vectors)
        W = np.linalg.solve(X,y)
        w = W[:-1]
        w = np.concatenate([w,np.ones(1)])
        c = W[-1]

        if not target[-1]:
            w = -w
            c = -c

        n = len(target)
        self.n = n
        self.linear = nn.Linear(n,1)

        self.linear.weight.data = torch.tensor(w.reshape(1,-1)).float()
        self.linear.bias.data = torch.tensor(c).unsqueeze(0).float()

    def forward(self,x):
        return self.linear(x)

    def __repr__(self):
        output = ""
        for i in range(self.n):
            if i < self.n - 1:
                output += f"{self.linear.weight.data[0][i]}*x_{i} + "
            else:
                output += f"{self.linear.weight.data[0][i]}*y + "
        output += f"{self.linear.bias.data[0]} = 0"
        return output

# Cell
import itertools

def create_test_cases_x(n):
    products = [[0,1]] * n

    x = list(itertools.product(*products))
    x = np.array(x)

    return x

def create_test_cases_y(x,target):
    y = ((x == target).sum(axis=1) == n).astype(int)
    return y

# Cell
def create_parent_of(n_nodes, is_leaves, children_left, children_right):
    parentOf = {}

    for i in range(n_nodes):
        if not is_leaves[i]:
            parentOf[children_left[i]] = (i,0)
            parentOf[children_right[i]] = (i,1)
    return parentOf

# Cell
def create_leaf_to_path(is_leaves,parentOf):
    leafToPath = []

    for i,isLeaf in enumerate(is_leaves):
        if isLeaf:
            node = i
            path = []

            parent = parentOf[node]

            while parent[0] != 0:
                path.append(parent)
                parent = parentOf[parent[0]]

            path.append(parent)
            leafToPath.append(path[::-1])

    return leafToPath

# Cell
def path_to_weight(path, nodes2idx):
    # This is the target of the Bitcomparison
    bits = [v for k,v in path]
    bit_comparison = BitComparison(bits)

    # Those are the indexes to be replaced by the corresponding weights
    idx = [nodes2idx[k] for k,v in path]

    K = len(nodes2idx)
    w = np.zeros(K)

    w[idx] = bit_comparison.linear.weight.data.numpy().reshape(-1)
    b = bit_comparison.linear.bias.data.numpy()

    return w,b