# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_activations.ipynb (unless otherwise specified).

__all__ = ['compute_leaves', 'create_linear_node_comparator', 'create_parent_of', 'create_leaf_to_path',
           'shift_bit_eps', 'create_base_vectors', 'create_linear_system', 'BitComparison', 'sigmoid_path_to_weight',
           'sigmoid_path_to_linear', 'sigmoid_linear_leaf_matcher', 'sigmoid_classification_head',
           'tanh_path_to_weight', 'tanh_path_to_linear', 'tanh_linear_leaf_matcher', 'tanh_classification_head']

# Cell
import numpy as np

import torch.nn as nn
import torch

from sklearn.tree import BaseDecisionTree

from typing import List, Tuple
from functools import partial

# Cell
def compute_leaves(n_nodes: int, children_left: List, children_right: List) -> Tuple:
    """Computes the leaves and the depth of a tree."""
    node_depth = np.zeros(shape=n_nodes, dtype=np.int64)

    is_leaves = np.zeros(shape=n_nodes, dtype=bool)
    stack = [(0, -1)]  # seed is the root node id and its parent depth
    while len(stack) > 0:
        node_id, parent_depth = stack.pop()
        node_depth[node_id] = parent_depth + 1

        # If we have a test node
        if (children_left[node_id] != children_right[node_id]):
            stack.append((children_left[node_id], parent_depth + 1))
            stack.append((children_right[node_id], parent_depth + 1))
        else:
            is_leaves[node_id] = True

    return node_depth, is_leaves

# Cell
def create_linear_node_comparator(tree: BaseDecisionTree) -> nn.Linear:
    """Creates a Linear module representing the operation of choosing which variable to compare."""
    n_nodes = tree.tree_.node_count
    children_left = tree.tree_.children_left
    children_right = tree.tree_.children_right

    feature = tree.tree_.feature
    threshold = tree.tree_.threshold

    d = tree.n_features_

    node_depth, is_leaves = compute_leaves(n_nodes, children_left, children_right)
    internal_nodes = [i for i,isLeaf in enumerate(is_leaves)if not isLeaf]

    W = []
    B = []

    for node in internal_nodes:
        w = np.zeros(d)
        w[feature[node]] = 1

        b = - threshold[node]
        W.append(w)
        B.append(b)

    W = np.stack(W)
    B = np.stack(B)

    linear = nn.Linear(W.shape[1],W.shape[0])
    linear.weight.data = torch.tensor(W).float()
    linear.bias.data = torch.tensor(B).float()

    return linear

# Cell
def create_parent_of(n_nodes, is_leaves, children_left, children_right,left_value=0,right_value=1):
    """Outputs a list which provides the index of the parent of a given node."""
    parentOf = {}

    for i in range(n_nodes):
        if not is_leaves[i]:
            parentOf[children_left[i]] = (i,left_value)
            parentOf[children_right[i]] = (i,right_value)
    return parentOf

# Cell
def create_leaf_to_path(n_nodes, is_leaves, children_left, children_right,left_value=0,right_value=1):
    """Outputs the path from the root to its leaves."""
    parentOf = create_parent_of(n_nodes, is_leaves, children_left, children_right,left_value,right_value)
    leafToPath = []

    for i,isLeaf in enumerate(is_leaves):
        if isLeaf:
            node = i
            path = []

            parent = parentOf[node]

            while parent[0] != 0:
                path.append(parent)
                parent = parentOf[parent[0]]

            path.append(parent)
            leafToPath.append(path[::-1])

    return leafToPath

# Cell
def shift_bit_eps(bit: int, eps: float = 0.5) -> float:
    """Shift the bit from 0 to 1-eps, and from 1 to eps"""
    assert bit in [0,1], "Bit must be 0 or 1"
    return (2 * eps - 1) * bit + 1 - eps

def create_base_vectors(circuit: List[int], eps: float = 0.5) -> List[List[float]]:
    """Create the base vectors from a circuit"""
    vectors = []
    n = len(circuit)

    for i in range(n):
        vector = list(circuit).copy()
        vector[i] = shift_bit_eps(vector[i], eps=eps)
        vectors.append(vector)

    return vectors

# Cell
def create_linear_system(vectors: List[List[float]]) -> Tuple:
    """Create a linear system from the base vectors"""
    X = np.array(vectors)

    y = -X[:,-1]

    X[:,-1] = 1

    return X,y

# Cell
class BitComparison(nn.Module):
    """Module to create a linear model which only outputs one when a specific binary circuit is given."""
    def __init__(self,target: List[int], eps : float = 0.5):
        super(BitComparison, self).__init__()

        vectors = create_base_vectors(target, eps=eps)
        X,y = create_linear_system(vectors)
        W = np.linalg.solve(X,y)
        w = W[:-1]
        w = np.concatenate([w,np.ones(1)])
        c = W[-1]

        if not target[-1]:
            w = -w
            c = -c

        n = len(target)
        self.n = n
        self.linear = nn.Linear(n,1)

        self.linear.weight.data = torch.tensor(w.reshape(1,-1)).float()
        self.linear.bias.data = torch.tensor(c).unsqueeze(0).float()

    def forward(self,x):
        return self.linear(x)

    def __repr__(self):
        output = ""
        for i in range(self.n):
            if i < self.n - 1:
                output += f"{self.linear.weight.data[0][i]}*x_{i} + "
            else:
                output += f"{self.linear.weight.data[0][i]}*y + "
        output += f"{self.linear.bias.data[0]} = 0"
        return output

# Cell
def sigmoid_path_to_weight(path, nodes2idx, eps=0.5):
    # This is the target of the Bitcomparison
    bits = [v for k,v in path]
    bit_comparison = BitComparison(bits, eps=eps)

    # Those are the indexes to be replaced by the corresponding weights
    idx = [nodes2idx[k] for k,v in path]

    K = len(nodes2idx)
    w = np.zeros(K)

    w[idx] = bit_comparison.linear.weight.data.numpy().reshape(-1)
    b = bit_comparison.linear.bias.data.numpy()

    return w,b

# Cell
def sigmoid_path_to_linear(leafToPath, nodes2idx, eps=0.5):

    # For each leaf, we compute the linear layer to match it
    W = []
    B = []
    for path in leafToPath:
        w,b = sigmoid_path_to_weight(path,nodes2idx, eps=eps)
        W.append(w)
        B.append(b)

    W = np.stack(W)
    B = np.stack(B)

    # We divide the weights
    K = len(nodes2idx)

    linear = nn.Linear(W.shape[1],W.shape[0])
    linear.weight.data = torch.tensor(W).float() / K
    linear.bias.data = torch.tensor(B).view(-1).float() / K

    return linear

# Cell
def sigmoid_linear_leaf_matcher(tree: BaseDecisionTree, eps=0.5) -> nn.Linear:

    n_nodes = tree.tree_.node_count
    children_left = tree.tree_.children_left
    children_right = tree.tree_.children_right
    node_depth, is_leaves = compute_leaves(n_nodes, children_left, children_right)

    leafToPath = create_leaf_to_path(n_nodes,is_leaves,children_left,children_right)

    internal_nodes = [i for i,isLeaf in enumerate(is_leaves) if not isLeaf]
    nodes2idx = {node : i for i, node in enumerate(internal_nodes)}

    matcher = sigmoid_path_to_linear(leafToPath,nodes2idx, eps=0.5)

    return matcher

# Cell
def sigmoid_classification_head(tree: BaseDecisionTree) -> nn.Linear:
    n_nodes = tree.tree_.node_count
    children_left = tree.tree_.children_left
    children_right = tree.tree_.children_right
    node_depth, is_leaves = compute_leaves(n_nodes, children_left, children_right)

    leaves = [i for i,isLeaf in enumerate(is_leaves) if isLeaf]

    values = tree.tree_.value[[0] + leaves]
    values = torch.tensor(values).float()
    values = values.squeeze(1)

    root_values = values[0]
    leaf_values = values[1:]

    leaf_values = (leaf_values - root_values.unsqueeze(0)) / root_values.max()
    root_values = root_values / root_values.max()

    head = nn.Linear(*leaf_values.shape)
    head.weight.data = leaf_values.T
    head.bias.data = root_values

    return head

# Cell
def tanh_path_to_weight(path, nodes2idx, node_depth, leaf, eps=0.5):
    bits = [v for k,v in path]
    assert (set(bits) == set([-1,1])) or (set(bits) == set([-1])) or (set(bits) == set([1])), f"Bits outside of -1 and 1 : {bits}"

    idx = [nodes2idx[k] for k,v in path]

    K = len(nodes2idx)
    w = np.zeros(K)

    w[idx] = bits
    b = -node_depth[leaf] + eps

    return w,b

# Cell
def tanh_path_to_linear(leafToPath, nodes2idx, idx2leaves, node_depth, eps=0.5):

    # For each leaf, we compute the linear layer to match it
    W = []
    B = []
    for leaf_id, path in enumerate(leafToPath):
        leaf = idx2leaves[leaf_id]
        w,b = tanh_path_to_weight(path, nodes2idx, node_depth, leaf, eps)
        W.append(w)
        B.append(b)

    W = np.stack(W)
    B = np.stack(B)

    # We divide the weights
    K = len(nodes2idx)

    linear = nn.Linear(W.shape[1],W.shape[0])
    linear.weight.data = torch.tensor(W).float() / (2 * K)
    linear.bias.data = torch.tensor(B).view(-1).float() / (2 * K)

    return linear

# Cell
def tanh_linear_leaf_matcher(tree: BaseDecisionTree, eps=0.5) -> nn.Linear:

    n_nodes = tree.tree_.node_count
    children_left = tree.tree_.children_left
    children_right = tree.tree_.children_right
    node_depth, is_leaves = compute_leaves(n_nodes, children_left, children_right)

    leafToPath = create_leaf_to_path(n_nodes,is_leaves,children_left,children_right,left_value=-1)

    internal_nodes = [i for i,isLeaf in enumerate(is_leaves) if not isLeaf]
    leaves = [i for i,isLeaf in enumerate(is_leaves) if isLeaf]

    nodes2idx = {node : i for i, node in enumerate(internal_nodes)}
    leaves2idx = { leaf : i for i,leaf in enumerate(leaves)}

    matcher = tanh_path_to_linear(leafToPath, nodes2idx, leaves, node_depth, eps)

    return matcher

# Cell
def tanh_classification_head(tree: BaseDecisionTree) -> nn.Linear:
    n_nodes = tree.tree_.node_count
    children_left = tree.tree_.children_left
    children_right = tree.tree_.children_right
    node_depth, is_leaves = compute_leaves(n_nodes, children_left, children_right)

    leaves = [i for i,isLeaf in enumerate(is_leaves) if isLeaf]

    leaf_values = tree.tree_.value[leaves]
    leaf_values = torch.tensor(leaf_values).float()

    leaf_values = leaf_values.squeeze(1) / tree.tree_.value[0].max()

    # We divide by 2 because we have -1 and 1 bits
    bias = leaf_values.sum(dim=0) / 2
    leaf_values = leaf_values / 2

    head = nn.Linear(*leaf_values.shape)
    head.weight.data = leaf_values.T
    head.bias.data = bias

    return head