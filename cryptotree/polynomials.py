# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_polynomials.ipynb (unless otherwise specified).

__all__ = ['chebyshev_approximation', 'polynomial_approximation_coefficients', 'plot_graph_function_approximation',
           'coeffs_to_plaintext', 'compute_all_powers', 'multiply_and_add_coeffs', 'polyeval_tree']

# Cell
from seal import *
import numpy as np
from numpy.polynomial import Polynomial
from numpy.polynomial.chebyshev import Chebyshev

import matplotlib.pyplot as plt
import torch

from typing import List

# Cell
def chebyshev_approximation(f, dilatation_factor=50, polynomial_degree=25, bound=1, convertToTensor=True):
    if convertToTensor:
        f_a = lambda x: f(torch.tensor(x*dilatation_factor))
    else:
        f_a = lambda x: f(x*dilatation_factor)

    domain = [-bound,bound]

    p = Chebyshev.interpolate(f_a,deg=polynomial_degree,domain=domain)
    return p, f_a

def polynomial_approximation_coefficients(f, dilatation_factor=50, polynomial_degree=25,
                                          bound=1, convertToTensor=True):
    p,_ = chebyshev_approximation(f, dilatation_factor, polynomial_degree, bound, convertToTensor)

    return Polynomial.cast(p).coef

def plot_graph_function_approximation(f, dilatation_factor=50, polynomial_degree=25, bound=1, convertToTensor=True):

    p, f_a = chebyshev_approximation(f, dilatation_factor, polynomial_degree, bound, convertToTensor)

    domain = [-bound,bound]
    x = np.linspace(*domain,100)
    y = f_a(x)
    pred = p(x)

    fig, ax = plt.subplots()

    # plot the function
    ax.plot(x,y, 'g', label="Sigmoid")
    ax.plot(x,pred,"b-", label=f"Polynomial approximation")
    ax.legend()

    # show the plot
    fig.suptitle(f"Tchebytchev polynomials with expansion a={dilatation_factor} and degree n={polynomial_degree}")
    fig.show()

    return fig,ax

# Cell
def coeffs_to_plaintext(coeffs: List[float], encoder: CKKSEncoder, scale: float) -> List[Plaintext]:
    """Computes the plaintext encodings of coefficients"""
    plain_coeffs = []

    for coef in coeffs:
        plain_coeff = Plaintext()
        encoder.encode(coef, scale, plain_coeff)
        plain_coeffs.append(plain_coeff)

    return plain_coeffs

def compute_all_powers(ctx : Ciphertext, degree: int, evaluator: Evaluator,
                       relin_keys: RelinKeys, verbose=False) -> List[Ciphertext]:
    """Computes all powers of a given ciphertext"""
    powers = [None] * (degree+1)
    levels = np.zeros(degree+1)

    powers[1] = ctx
    levels[0] = levels[1] = 0


    for i in range(2,degree+1):

        minlevel = i
        cand = -1

        for j in range(1, i // 2 +1):
            k = i - j
            newlevel = max(levels[k],levels[j]) + 1
            if newlevel < minlevel:
                cand = j
                minlevel = newlevel

        if verbose:
            print(f"i = {i}, i-cand = {i-cand}")
            print(f"level for cand : {levels[cand]}, level for {i-cand} : {levels[i-cand]}")
            print(f"minlevel = {minlevel}")
            print(f"cand = {cand}")

        levels[i] = minlevel

        temp = Ciphertext()

        power_cand = powers[cand]
        evaluator.mod_switch_to(power_cand, powers[i-cand].parms_id(),temp)
        evaluator.multiply(temp, powers[i-cand], temp)
        evaluator.relinearize_inplace(temp, relin_keys)
        evaluator.rescale_to_next_inplace(temp)

        powers[i] = temp

    return powers

# Cell
from .seal_helper import ctx_value

def multiply_and_add_coeffs(powers: List[Ciphertext], plain_coeffs: List[Plaintext],
                            coeffs: List[float],
                            evaluator: Evaluator, encryptor: Encryptor,
                            tol=1e-3, verbose=False) -> Ciphertext:
    assert len(powers) == len(plain_coeffs), f"Mismatch between length between powers {len(powers)} and coeffs {len(coeffs)}"
    output = Ciphertext()

    x = ctx_value(powers[1])

    expected_output = coeffs[0]
    encryptor.encrypt(plain_coeffs[0],output)

    temp = Ciphertext()

    for i in range(1, len(plain_coeffs)):
        # We first check if the coefficient is not too small otherwise we skip it
        coef = coeffs[i]
        if np.abs(coef) < tol:
            continue

        plain_coeff = plain_coeffs[i]
        power = powers[i]

        evaluator.mod_switch_to_inplace(plain_coeff, power.parms_id())

        evaluator.multiply_plain(power, plain_coeff, temp)
        evaluator.rescale_to_next_inplace(temp)

        evaluator.mod_switch_to_inplace(output, temp.parms_id())
        output.scale(pow(2.0,PRECISION_BITS))
        temp.scale(pow(2.0,PRECISION_BITS))
        evaluator.add_inplace(output, temp)

        expected_output = coef * (x ** i)
        if verbose:
            print(f"{i} Expected output : {expected_output}, output : {ctx_value(temp)}")
    return output

# Cell
def polyeval_tree(ctx : Ciphertext, coeffs: List[float],
                  evaluator: Evaluator, encoder : Encryptor, encryptor : Encryptor,
                  relin_keys: RelinKeys,
                  scale: float,
                  verbose=False):

    degree = len(coeffs) - 1
    plain_coeffs = coeffs_to_plaintext(coeffs, encoder, scale)
    powers = compute_all_powers(ctx, degree, evaluator, relin_keys)
    output = multiply_and_add_coeffs(powers, plain_coeffs, coeffs, evaluator, encryptor, verbose=verbose)

    return output